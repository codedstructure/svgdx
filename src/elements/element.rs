use super::{
    is_connector, process_path_bearing, process_text_attr, ConfigElement, ConnectionType,
    Connector, Container, DefaultsElement, ForElement, GroupElement, IfElement, LoopElement,
    ReuseElement, SpecsElement, VarElement,
};
use crate::context::{ContextView, ElementMap, TransformerContext};
use crate::errors::{Result, SvgdxError};
use crate::events::{InputList, OutputEvent, OutputList};
use crate::expr::eval_attr;
use crate::geometry::{BoundingBox, TransformAttr};
use crate::transform::EventGen;
use crate::types::{extract_urlref, strp, AttrMap, ClassList, OrderIndex};

use core::fmt::Display;

impl EventGen for SvgElement {
    fn generate_events(
        &self,
        context: &mut TransformerContext,
    ) -> Result<(OutputList, Option<BoundingBox>)> {
        context.inc_depth()?;
        // early update: may be updated further during processing
        context.update_element(self);
        let res = match self.name() {
            "loop" => LoopElement(self.clone()).generate_events(context),
            "config" => ConfigElement(self.clone()).generate_events(context),
            "reuse" => ReuseElement(self.clone()).generate_events(context),
            "specs" => SpecsElement(self.clone()).generate_events(context),
            "var" => VarElement(self.clone()).generate_events(context),
            "if" => IfElement(self.clone()).generate_events(context),
            "defaults" => DefaultsElement(self.clone()).generate_events(context),
            "for" => ForElement(self.clone()).generate_events(context),
            "g" | "symbol" => GroupElement(self.clone()).generate_events(context),
            _ => {
                if let Some((start, end)) = self.event_range {
                    if start != end {
                        return Container(self.clone()).generate_events(context);
                    }
                }
                OtherElement(self.clone()).generate_events(context)
            }
        };
        // Ideally would have a single 'if bbox, set prev_element' here,
        // but is used for attribute lookup as well as bbox, so need the
        // full *resolved* element, which isn't available here.
        // TODO: see if just storing a 'prev_bbox' is feasible.
        context.dec_depth()?;

        let (ol, mut bbox) = res?;

        if let (Some(el_bbox), Some(clip_id)) =
            (bbox, self.get_attr("clip-path").and_then(extract_urlref))
        {
            let clip_el = context
                .get_element(&clip_id)
                .ok_or(SvgdxError::ReferenceError(clip_id))?;
            if let ("clipPath", Some(clip_bbox)) =
                (clip_el.name.as_str(), context.get_element_bbox(clip_el)?)
            {
                bbox = el_bbox.intersect(&clip_bbox);
                let mut el = self.clone();
                el.content_bbox = bbox;
                context.update_element(&el);
            }
        }

        Ok((ol, bbox))
    }
}

#[derive(Debug, Clone)]
struct OtherElement(pub SvgElement);

impl EventGen for OtherElement {
    fn generate_events(
        &self,
        context: &mut TransformerContext,
    ) -> Result<(OutputList, Option<BoundingBox>)> {
        let mut output = OutputList::new();
        let mut e = self.0.clone();
        e.resolve_position(context)?; // transmute assumes some of this (e.g. dxy -> dx/dy) has been done
        e.transmute(context)?;
        context.update_element(&e);
        let mut bb = context.get_element_bbox(&e)?;
        let events = e.element_events(context)?;
        for svg_ev in events {
            let is_empty = matches!(svg_ev, OutputEvent::Empty(_));
            let adapted = if let OutputEvent::Empty(e) | OutputEvent::Start(e) = svg_ev {
                let mut new_el = SvgElement::new(&e.name, &[]);
                // Collect pass-through attributes
                for (k, v) in e.attrs {
                    if k != "class" && k != "data-src-line" && k != "_" && k != "__" {
                        new_el.set_attr(&k, &v);
                    }
                }

                // TODO: have a range of debug options to include/exclude
                // new_el.set_attr("_oi", &e.order_index.to_string());

                // Any 'class' attribute values are stored separately as a HashSet;
                // collect those into the BytesStart object
                if !e.classes.is_empty() {
                    new_el.add_classes(&e.classes);
                }
                // Add 'data-src-line' for all elements generated by input `element`
                if context.config.add_metadata {
                    new_el.set_attr("data-src-line", &e.src_line.to_string());
                }
                if is_empty {
                    OutputEvent::Empty(new_el)
                } else {
                    OutputEvent::Start(new_el)
                }
            } else {
                svg_ev
            };

            output.push(adapted);
        }
        if self.0.name == "point" {
            // point elements don't contribute to parent bounding box,
            // and are primarily used for update_element() side-effects.
            // (They can generate text though, so not rejected earlier.)
            bb = None;
        }
        Ok((output, bb))
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SvgElement {
    name: String,
    pub original: String,
    attrs: AttrMap,
    classes: ClassList,
    pub text_content: Option<String>,
    pub order_index: OrderIndex,
    pub indent: usize,
    pub src_line: usize,
    pub event_range: Option<(usize, usize)>,
    pub content_bbox: Option<BoundingBox>,
}

impl Display for SvgElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<{}", self.name)?;
        if !self.attrs.is_empty() {
            write!(f, " {}", self.attrs)?;
        }
        let c = self.get_classes();
        if !c.is_empty() {
            write!(f, r#" class="{}""#, c.join(" "))?;
        }
        write!(f, ">")?;
        Ok(())
    }
}

impl SvgElement {
    pub fn new(name: &str, attrs: &[(String, String)]) -> Self {
        let mut attr_map = AttrMap::new();
        let mut classes = ClassList::new();

        for (key, value) in attrs {
            if key == "class" {
                for c in value.split(' ') {
                    classes.insert(c.to_string());
                }
            } else {
                attr_map.insert(key.to_string(), value.to_string());
            }
        }
        Self {
            name: name.to_string(),
            original: format!("<{name} {}>", attr_map),
            attrs: attr_map.clone(),
            classes,
            text_content: None,
            order_index: OrderIndex::default(),
            indent: 0,
            src_line: 0,
            event_range: None,
            content_bbox: None,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn add_class(&mut self, class: &str) -> Self {
        self.classes.insert(class.to_string());
        self.clone()
    }

    pub fn add_classes(&mut self, classes: &ClassList) {
        for class in classes {
            // update classes directly rather than use add_class which
            // performs a clone() operation.
            self.classes.insert(class.to_string());
        }
    }

    pub fn add_classes_from(&mut self, other: &Self) {
        for class in other.get_classes() {
            self.add_class(&class);
        }
    }

    pub fn set_classes(&mut self, classes: &Vec<String>) {
        self.classes.clear();
        for class in classes {
            self.add_class(class);
        }
    }

    pub fn has_class(&self, class: &str) -> bool {
        self.classes.contains(class)
    }

    /// Remove a class from the element, returning `true` if the class was present
    pub fn pop_class(&mut self, class: &str) -> bool {
        self.classes.remove(class)
    }

    pub fn get_classes(&self) -> Vec<String> {
        self.classes.to_vec()
    }

    pub fn has_attr(&self, key: &str) -> bool {
        self.attrs.contains_key(key)
    }

    fn replace_attrs(&mut self, attrs: AttrMap) {
        self.attrs = attrs;
    }

    #[allow(dead_code)]
    #[must_use]
    fn with_attr(&self, key: &str, value: &str) -> Self {
        let mut element = self.clone();
        element.set_attr(key, value);
        element
    }

    #[must_use]
    pub fn without_attr(&self, key: &str) -> Self {
        let attrs: Vec<(String, String)> = self
            .attrs
            .clone()
            .into_iter()
            .filter(|(k, _v)| k != key)
            .collect();
        let mut element = self.clone();
        element.replace_attrs(attrs.into());
        element
    }

    /// copy attributes, classes and indentation from another element,
    /// returning the merged element
    #[must_use]
    pub fn with_attrs_from(&self, other: &Self) -> Self {
        let mut attrs = self.attrs.clone();
        for (k, v) in &other.attrs {
            attrs.insert(k, v);
        }
        let mut element = other.clone();
        element.replace_attrs(attrs);
        // Everything but the name and any attrs unique to the original element
        // is from the other element.
        element.name.clone_from(&self.name);
        element
    }

    pub fn pop_attr(&mut self, key: &str) -> Option<String> {
        self.attrs.pop(key)
    }

    pub fn remove_attrs(&mut self, keys: &[&str]) {
        for key in keys {
            self.pop_attr(key);
        }
    }

    pub fn get_attr(&self, key: &str) -> Option<&str> {
        self.attrs.get(key).map(|s| s.as_str())
    }

    pub fn set_attr(&mut self, key: &str, value: &str) {
        self.attrs.insert(key, value);
    }

    /// set an attribute key/value if the key does not already exist
    pub fn set_default_attr(&mut self, key: &str, value: &str) {
        if !self.has_attr(key) {
            self.set_attr(key, value);
        }
    }

    /// order-preserving attribute list
    pub fn get_attrs(&self) -> Vec<(String, String)> {
        self.attrs.to_vec()
    }
}

impl SvgElement {
    pub fn inner_events(&self, context: &TransformerContext) -> Option<InputList> {
        if let Some((start, end)) = self.event_range {
            // empty events will have end == start
            if end > start {
                return Some(InputList::from(&context.events[start + 1..end]));
            }
        }
        None
    }

    pub fn all_events(&self, context: &TransformerContext) -> InputList {
        if let Some((start, end)) = self.event_range {
            InputList::from(&context.events[start..end + 1])
        } else {
            InputList::new()
        }
    }

    /// Process a given `SvgElement` into a list of `SvgEvent`s
    // TODO: would be nice to make this infallible and have any potential errors handled earlier.
    pub fn element_events(&self, ctx: &mut TransformerContext) -> Result<Vec<OutputEvent>> {
        let mut events = vec![];

        if ctx.config.debug {
            // Prefix replaced element(s) with a representation of the original element
            //
            // Replace double quote with backtick to avoid messy XML entity conversion
            // (i.e. &quot; or &apos; if single quotes were used)
            events.push(OutputEvent::Comment(
                format!(" {} ", self.original)
                    .replace('"', "`")
                    .replace(['<', '>'], ""),
            ));
            events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // Standard comment: expressions & variables are evaluated.
        if let Some(comment) = self.get_attr("_") {
            // Expressions in comments are evaluated
            let value = eval_attr(comment, ctx)?;
            events.push(OutputEvent::Comment(format!(" {value} ")));
            events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // 'Raw' comment: no evaluation of expressions occurs here
        if let Some(comment) = self.get_attr("__") {
            events.push(OutputEvent::Comment(format!(" {comment} ")));
            events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // Some elements don't generate text themselves, but can have
        // associated text.
        // TODO: refactor this method to handle text event gen better
        let phantom = matches!(self.name(), "point" | "box");

        if self.has_attr("text") {
            let (orig_elem, text_elements) = process_text_attr(self)?;
            if orig_elem.name != "text" && !phantom {
                // We only care about the original element if it wasn't a text element
                // (otherwise we generate a useless empty text element for the original)
                events.push(OutputEvent::Empty(orig_elem));
                events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
            }
            match text_elements.as_slice() {
                [] => {}
                [elem] => {
                    events.push(OutputEvent::Start(elem.clone()));
                    if let Some(value) = &elem.text_content {
                        events.push(OutputEvent::Text(value.clone()));
                    } else {
                        return Err(SvgdxError::InvalidData(
                            "Text element should have content".to_owned(),
                        ));
                    }
                    events.push(OutputEvent::End("text".to_string()));
                }
                _ => {
                    // Multiple text spans
                    let text_elem = &text_elements[0];
                    events.push(OutputEvent::Start(text_elem.clone()));
                    events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
                    for elem in &text_elements[1..] {
                        // Note: we can't insert a newline/last_indent here as whitespace
                        // following a tspan is compressed to a single space and causes
                        // misalignment - see https://stackoverflow.com/q/41364908
                        events.push(OutputEvent::Start(elem.clone()));
                        if let Some(value) = &elem.text_content {
                            events.push(OutputEvent::Text(value.clone()));
                        } else {
                            return Err(SvgdxError::InvalidData(
                                "Text element should have content".to_owned(),
                            ));
                        }
                        events.push(OutputEvent::End("tspan".to_string()));
                    }
                    events.push(OutputEvent::Text(format!("\n{}", " ".repeat(self.indent))));
                    events.push(OutputEvent::End("text".to_string()));
                }
            }
        } else if !phantom {
            if self.is_empty_element() {
                events.push(OutputEvent::Empty(self.clone()));
            } else {
                events.push(OutputEvent::Start(self.clone()));
            }
        }

        Ok(events)
    }

    pub fn set_indent(&mut self, indent: usize) {
        self.indent = indent;
    }

    pub fn set_src_line(&mut self, line: usize) {
        self.src_line = line;
    }

    pub fn set_order_index(&mut self, order_index: &OrderIndex) {
        self.order_index = order_index.clone();
    }

    pub fn set_event_range(&mut self, range: (usize, usize)) {
        self.event_range = Some(range);
    }

    pub fn is_empty_element(&self) -> bool {
        if let Some((start, end)) = self.event_range {
            start == end
        } else {
            true
        }
    }
}

impl SvgElement {
    pub fn transmute(&mut self, ctx: &impl ContextView) -> Result<()> {
        if self.name == "path" {
            if let Some(d) = self.get_attr("d") {
                if d.chars().any(|c| c == 'b' || c == 'B') {
                    self.set_attr("d", &process_path_bearing(d)?)
                }
            }
        }

        if is_connector(self) {
            if let Ok(conn) = Connector::from_element(
                self,
                ctx,
                if let Some(e_type) = self.get_attr("edge-type") {
                    ConnectionType::from_str(e_type)
                } else if self.name() == "polyline" {
                    ConnectionType::Corner
                } else {
                    ConnectionType::Straight
                },
            ) {
                // replace with rendered connection element
                *self = conn.render(ctx)?.without_attr("edge-type");
            } else {
                return Err(SvgdxError::InvalidData(
                    "Cannot create connector".to_owned(),
                ));
            }
        }

        if self.name() == "use" {
            // rotation requires a bbox to identify center of rotation; for `<use>`
            // elements derive from context and inject via `content_bbox`. Allows
            // handle_rotation to be independent of context.
            if let Some(bbox) = ctx.get_element_bbox(self)? {
                self.content_bbox = Some(bbox);
            }
        }
        self.handle_rotation()?;

        Ok(())
    }

    /// Resolve any expressions in attributes.
    pub fn eval_attributes(&mut self, ctx: &impl ContextView) -> Result<()> {
        // Resolve any attributes
        for (key, value) in self.attrs.clone() {
            if key == "__" {
                // Raw comments are not evaluated
                continue;
            }
            let replace = eval_attr(&value, ctx)?;
            self.set_attr(&key, &replace);
        }
        // Classes are handled separately to other attributes
        for class in &self.get_classes() {
            self.pop_class(class);
            let new = eval_attr(class, ctx)?;
            for class in new.split_whitespace() {
                self.add_class(class);
            }
        }

        Ok(())
    }

    pub fn handle_rotation(&mut self) -> Result<()> {
        let angle = self.pop_attr("rotate");
        if angle.is_none() {
            return Ok(());
        }
        let angle = angle.unwrap();
        let angle = strp(&angle)?;
        if let Some((cx, cy)) = self.bbox()?.map(|bb| bb.center()) {
            let mut rot_xfrm = TransformAttr::new();
            rot_xfrm.rotate_around(angle, cx, cy);
            if let Some(xfrm) = self.pop_attr("transform") {
                // rotation should be the outermost transform, so prepend it
                self.set_attr("transform", &format!("{rot_xfrm} {xfrm}"));
            } else {
                self.set_attr("transform", &rot_xfrm.to_string());
            }
        }
        Ok(())
    }
}
