use super::{
    is_connector, process_text_attr, ConfigElement, ConnectorType, Container, DefaultsElement,
    ForElement, GroupElement, IfElement, LinearGradient, LoopElement, RadialGradient, ReuseElement,
    SpecsElement, VarElement,
};
use crate::context::{ConfigView, ContextView, ElementMap, TransformerContext};
use crate::document::{EventKind, InputList, OutputList};
use crate::elements::path::{points_to_path, process_path_bearing, process_path_repeat};
use crate::errors::{Error, Result};
use crate::expr::eval_attr;
use crate::geometry::{BoundingBox, TransformAttr};
use crate::style::{Selectable, Stylable};
use crate::transform::EventGen;
use crate::types::{extract_urlref, strp, AttrMap, ClassList, OrderIndex, StyleMap};

use core::fmt::Display;

impl EventGen for SvgElement {
    fn generate_events(
        &self,
        context: &mut TransformerContext,
    ) -> Result<(OutputList, Option<BoundingBox>)> {
        context.inc_depth()?;
        // early update: may be updated further during processing
        context.update_element(self);
        let res = match self.name() {
            "loop" => LoopElement(self).generate_events(context),
            "config" => ConfigElement(self).generate_events(context),
            "reuse" => ReuseElement(self).generate_events(context),
            "specs" => SpecsElement(self).generate_events(context),
            "var" => VarElement(self).generate_events(context),
            "if" => IfElement(self).generate_events(context),
            "defaults" => DefaultsElement(self).generate_events(context),
            "for" => ForElement(self).generate_events(context),
            "g" | "symbol" => GroupElement(self).generate_events(context),
            "linearGradient" => LinearGradient(self).generate_events(context),
            "radialGradient" => RadialGradient(self).generate_events(context),
            _ => match self.event_range {
                Some((start, end)) if start != end => {
                    return Container(self).generate_events(context);
                }
                _ => OtherElement(self).generate_events(context),
            },
        };
        context.dec_depth()?;

        let (ol, mut bbox) = res?;

        if let (Some(el_bbox), Some(clip_id)) =
            (bbox, self.get_attr("clip-path").and_then(extract_urlref))
        {
            let clip_el = context
                .get_element(&clip_id)
                .ok_or_else(|| Error::Reference(clip_id))?;
            if let ("clipPath", Some(clip_bbox)) =
                (clip_el.name.as_str(), context.get_element_bbox(clip_el)?)
            {
                bbox = el_bbox.intersect(&clip_bbox);
                let mut el = self.clone();
                el.content_bbox = bbox;
                context.update_element(&el);
            }
        }

        Ok((ol, bbox))
    }
}

#[derive(Debug, Clone)]
struct OtherElement<'a>(pub &'a SvgElement);

impl EventGen for OtherElement<'_> {
    fn generate_events(
        &self,
        context: &mut TransformerContext,
    ) -> Result<(OutputList, Option<BoundingBox>)> {
        let mut output = OutputList::new();
        let mut e = self.0.clone();
        e.resolve_position(context)?; // transmute assumes some of this (e.g. dxy -> dx/dy) has been done
        if !e.transmute(context)? {
            // Element should be skipped (e.g. overlapping connectors)
            return Ok((output, None));
        }

        context.update_element(&e);
        let mut bb = context.get_element_bbox(&e)?;
        let events = e.element_events(context)?;
        for svg_ev in events {
            let is_empty = matches!(svg_ev, EventKind::Empty(_));
            let adapted = if let EventKind::Empty(mut raw) | EventKind::Start(mut raw) = svg_ev {
                let attrs = raw.get_attrs_mut();
                attrs.retain(|(k, _v)| k != "data-src-line" && k != "_" && k != "__");

                // TODO: have a range of debug options to include/exclude
                // attrs.push(("_oi".into(), e.order_index.to_string()));

                // Add 'data-src-line' for all elements generated by input `element`
                if context.config.add_metadata {
                    attrs.push(("data-src-line".into(), e.src_line.to_string()));
                }
                if is_empty {
                    EventKind::Empty(raw)
                } else {
                    EventKind::Start(raw)
                }
            } else {
                svg_ev
            };

            output.push(adapted);
        }
        if self.0.name == "point" {
            // point elements don't contribute to parent bounding box,
            // and are primarily used for update_element() side-effects.
            // (They can generate text though, so not rejected earlier.)
            bb = None;
        }
        Ok((output, bb))
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SvgElement {
    name: String,
    pub original: String,
    attrs: AttrMap,
    classes: ClassList,
    styles: StyleMap,
    pub text_content: Option<String>,
    pub order_index: OrderIndex,
    pub indent: usize,
    pub src_line: usize,
    pub event_range: Option<(usize, usize)>,
    pub content_bbox: Option<BoundingBox>,
}

impl Display for SvgElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<{}", self.name)?;
        if !self.attrs.is_empty() {
            write!(f, " {}", self.attrs)?;
        }
        let c = self.get_classes().join(" ");
        if !c.is_empty() {
            write!(f, r#" class="{c}""#)?;
        }
        let s = self.styles.to_string();
        if !s.is_empty() {
            write!(f, r#" style="{s}""#)?;
        }
        write!(f, ">")?;
        Ok(())
    }
}

impl Selectable for SvgElement {
    fn name(&self) -> &str {
        self.name()
    }

    fn get_classes(&self) -> Vec<String> {
        self.get_classes()
    }
}

impl Stylable for SvgElement {
    fn apply_styles(&mut self, styles: &StyleMap) {
        self.apply_auto_styles(styles);
    }
}

impl SvgElement {
    pub fn new(name: &str, attrs: &[(String, String)]) -> Self {
        let mut attr_map = AttrMap::new();
        let mut classes = ClassList::new();
        let mut styles = StyleMap::new();

        for (key, value) in attrs {
            if key == "class" {
                for c in value.split(' ') {
                    classes.insert(c.to_string());
                }
            } else if key == "style" {
                if let Ok(s) = value.parse() {
                    styles = s;
                } else {
                    // If parsing fails, treat as a regular attribute -
                    // at least it will get round-tripped.
                    attr_map.insert(key.to_string(), value.to_string());
                }
            } else {
                attr_map.insert(key.to_string(), value.to_string());
            }
        }
        Self {
            name: name.to_string(),
            original: format!("<{name} {attr_map}>"),
            attrs: attr_map.clone(),
            classes,
            styles,
            text_content: None,
            order_index: OrderIndex::default(),
            indent: 0,
            src_line: 0,
            event_range: None,
            content_bbox: None,
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn add_class(&mut self, class: &str) -> Self {
        self.classes.insert(class.to_string());
        self.clone()
    }

    pub fn add_classes(&mut self, classes: &ClassList) {
        for class in classes {
            // update classes directly rather than use add_class which
            // performs a clone() operation.
            self.classes.insert(class.to_string());
        }
    }

    pub fn add_classes_from(&mut self, other: &Self) {
        for class in other.get_classes() {
            self.add_class(&class);
        }
    }

    pub fn set_classes(&mut self, classes: &Vec<String>) {
        self.classes.clear();
        for class in classes {
            self.add_class(class);
        }
    }

    pub fn has_class(&self, class: &str) -> bool {
        self.classes.contains(class)
    }

    /// Remove a class from the element, returning `true` if the class was present
    pub fn pop_class(&mut self, class: &str) -> bool {
        self.classes.remove(class)
    }

    pub fn get_classes(&self) -> Vec<String> {
        self.classes.to_vec()
    }

    pub fn add_style(&mut self, key: &str, value: &str) {
        self.styles.insert(key.to_string(), value.to_string());
    }

    pub fn add_auto_style(&mut self, key: &str, value: &str) {
        // Add a style only if it doesn't already exist
        if !self.styles.contains_key(key) {
            self.add_style(key, value);
        }
    }

    pub fn apply_auto_styles(&mut self, styles: &StyleMap) {
        for (key, value) in styles {
            if !self.styles.contains_key(key) {
                self.styles.insert(key, value);
            }
        }
    }

    pub fn add_styles_from(&mut self, other: &Self) {
        for (key, value) in &other.styles {
            // TODO: should this be an add_auto_style?
            self.add_style(key, value);
        }
    }

    pub fn get_styles(&self) -> &StyleMap {
        &self.styles
    }

    pub fn set_styles(&mut self, styles: StyleMap) {
        self.styles = styles;
    }

    pub fn set_style_from(&mut self, style: &str) {
        if let Ok(styles) = style.parse() {
            self.styles = styles;
        } else {
            // malformed style, treat as a regular attribute
            self.attrs.insert("style".to_string(), style.to_string());
        }
    }

    pub fn has_attr(&self, key: &str) -> bool {
        self.attrs.contains_key(key)
    }

    fn replace_attrs(&mut self, attrs: AttrMap) {
        self.attrs = attrs;
    }

    #[allow(dead_code)]
    #[must_use]
    fn with_attr(&self, key: &str, value: &str) -> Self {
        let mut element = self.clone();
        element.set_attr(key, value);
        element
    }

    #[must_use]
    pub fn without_attr(&self, key: &str) -> Self {
        let attrs: Vec<(String, String)> = self
            .attrs
            .clone()
            .into_iter()
            .filter(|(k, _v)| k != key)
            .collect();
        let mut element = self.clone();
        element.replace_attrs(attrs.into());
        element
    }

    /// copy attributes, classes and indentation from another element,
    /// returning the merged element
    #[must_use]
    pub fn with_attrs_from(&self, other: &Self) -> Self {
        let mut attrs = self.attrs.clone();
        for (k, v) in &other.attrs {
            attrs.insert(k, v);
        }
        let mut element = other.clone();
        element.replace_attrs(attrs);
        // Everything but the name and any attrs unique to the original element
        // is from the other element.
        element.name.clone_from(&self.name);
        element
    }

    pub fn pop_attr(&mut self, key: &str) -> Option<String> {
        self.attrs.pop(key)
    }

    pub fn remove_attrs(&mut self, keys: &[&str]) {
        for key in keys {
            self.pop_attr(key);
        }
    }

    pub fn get_attr(&self, key: &str) -> Option<&str> {
        self.attrs.get(key)
    }

    pub fn set_attr(&mut self, key: &str, value: &str) {
        self.attrs.insert(key, value);
    }

    /// set an attribute key/value if the key does not already exist
    pub fn set_default_attr(&mut self, key: &str, value: &str) {
        if !self.has_attr(key) {
            self.set_attr(key, value);
        }
    }

    /// order-preserving attribute list
    pub fn get_attrs(&self) -> Vec<(String, String)> {
        self.attrs.to_vec()
    }

    /// get attrs including styles and classes
    pub fn get_full_attrs(&self) -> Vec<(String, String)> {
        let mut all_attrs = self.attrs.to_vec();
        if !self.styles.is_empty() {
            all_attrs.push(("style".to_string(), self.styles.to_string()));
        }
        if !self.classes.is_empty() {
            all_attrs.push(("class".to_string(), self.get_classes().join(" ")));
        }
        all_attrs
    }
}

impl SvgElement {
    pub fn inner_events(&self, context: &TransformerContext) -> Option<InputList> {
        if let Some((start, end)) = self.event_range {
            // empty events will have end == start
            if end > start {
                return Some(InputList::from(&context.events[start + 1..end]));
            }
        }
        None
    }

    pub fn all_events(&self, context: &TransformerContext) -> InputList {
        if let Some((start, end)) = self.event_range {
            InputList::from(&context.events[start..end + 1])
        } else {
            InputList::new()
        }
    }

    /// Process a given `SvgElement` into a list of `SvgEvent`s
    // TODO: would be nice to make this infallible and have any potential errors handled earlier.
    pub fn element_events(&self, ctx: &mut TransformerContext) -> Result<OutputList> {
        let mut events = OutputList::new(); //vec![];

        if ctx.config.debug {
            // Prefix replaced element(s) with a representation of the original element
            //
            // Replace double quote with backtick to avoid messy XML entity conversion
            // (i.e. &quot; or &apos; if single quotes were used)
            events.push(EventKind::Comment(
                format!(" {} ", self.original)
                    .replace('"', "`")
                    .replace(['<', '>'], ""),
            ));
            events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // Standard comment: expressions & variables are evaluated.
        if let Some(comment) = self.get_attr("_") {
            // Expressions in comments are evaluated
            let value = eval_attr(comment, ctx)?;
            events.push(EventKind::Comment(format!(" {value} ")));
            events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // 'Raw' comment: no evaluation of expressions occurs here
        if let Some(comment) = self.get_attr("__") {
            events.push(EventKind::Comment(format!(" {comment} ")));
            events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
        }

        // Some elements don't generate text themselves, but can have
        // associated text.
        // TODO: refactor this method to handle text event gen better
        let phantom = matches!(self.name(), "point" | "box");

        if self.has_attr("text") {
            let (orig_elem, text_elements) = process_text_attr(self)?;

            if orig_elem.name != "text" && !phantom {
                // We only care about the original element if it wasn't a text element
                // (otherwise we generate a useless empty text element for the original)
                events.push(EventKind::Empty(orig_elem.into()));
                events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
            }
            match text_elements.as_slice() {
                [] => {}
                [elem] => {
                    events.push(EventKind::Start(elem.clone().into()));
                    if let Some(value) = &elem.text_content {
                        events.push(EventKind::Text(value.clone()));
                    } else {
                        return Err(Error::InternalLogic(
                            "text element should have content".to_owned(),
                        ));
                    }
                    events.push(EventKind::End("text".to_string()));
                }
                _ => {
                    // Multiple text spans
                    let text_elem = &text_elements[0];
                    events.push(EventKind::Start(text_elem.clone().into()));
                    events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
                    for elem in &text_elements[1..] {
                        // Note: we can't insert a newline/last_indent here as whitespace
                        // following a tspan is compressed to a single space and causes
                        // misalignment - see https://stackoverflow.com/q/41364908
                        events.push(EventKind::Start(elem.clone().into()));
                        if let Some(value) = &elem.text_content {
                            events.push(EventKind::Text(value.clone()));
                        } else {
                            return Err(Error::InternalLogic(
                                "text element should have content".to_owned(),
                            ));
                        }
                        events.push(EventKind::End("tspan".to_string()));
                    }
                    events.push(EventKind::Text(format!("\n{}", " ".repeat(self.indent))));
                    events.push(EventKind::End("text".to_string()));
                }
            }
        } else if !phantom {
            if self.is_empty_element() {
                events.push(EventKind::Empty(self.clone().into()));
            } else {
                events.push(EventKind::Start(self.clone().into()));
            }
        }

        Ok(events)
    }

    pub fn set_indent(&mut self, indent: usize) {
        self.indent = indent;
    }

    pub fn set_src_line(&mut self, line: usize) {
        self.src_line = line;
    }

    pub fn set_order_index(&mut self, order_index: &OrderIndex) {
        self.order_index = order_index.clone();
    }

    pub fn set_event_range(&mut self, range: (usize, usize)) {
        self.event_range = Some(range);
    }

    pub fn is_empty_element(&self) -> bool {
        if let Some((start, end)) = self.event_range {
            start == end
        } else {
            true
        }
    }
}

impl SvgElement {
    /// Returns Ok(true) if element should be included, Ok(false) if it should be skipped
    pub fn transmute<T: ContextView + ConfigView>(&mut self, ctx: &T) -> Result<bool> {
        if self.name == "path" {
            if let Some(d) = self.get_attr("d") {
                let mut d = d.to_string();
                if d.chars().any(|c| c == 'r' || c == 'R') {
                    d = process_path_repeat(&d, ctx.config().path_repeat_limit)?;
                }
                if d.chars().any(|c| c == 'b' || c == 'B') {
                    d = process_path_bearing(&d)?;
                }
                self.set_attr("d", &d);
            }
        }

        if is_connector(self) {
            let conn = ConnectorType::from_element(self, ctx)?;
            // replace with rendered connection element, or skip if None
            if let Some(rendered) = conn.render(ctx)? {
                *self = rendered;
            } else {
                return Ok(false);
            }
        }

        if let (Some(_), Some(_)) = (self.get_attr("corner-radius"), self.get_attr("points")) {
            let res = points_to_path(self);
            if let Ok(res) = res {
                *self = res;
            }
        }

        if self.name() == "use" {
            // rotation requires a bbox to identify center of rotation; for `<use>`
            // elements derive from context and inject via `content_bbox`. Allows
            // handle_rotation to be independent of context.
            if let Some(bbox) = ctx.get_element_bbox(self)? {
                self.content_bbox = Some(bbox);
            }
        }
        self.handle_rotation()?;

        Ok(true)
    }

    /// Resolve any expressions in attributes.
    pub fn eval_attributes(&mut self, ctx: &impl ContextView) -> Result<()> {
        // Resolve any attributes
        for (key, value) in self.attrs.clone() {
            if key == "__" {
                // Raw comments are not evaluated
                continue;
            }
            let replace = eval_attr(&value, ctx)?;
            self.set_attr(&key, &replace);
        }
        // Classes are handled separately to other attributes
        for class in &self.get_classes() {
            self.pop_class(class);
            let new = eval_attr(class, ctx)?;
            for class in new.split_whitespace() {
                self.add_class(class);
            }
        }
        for (key, value) in self.styles.clone() {
            let replace = eval_attr(&value, ctx)?;
            self.styles.insert(key, replace);
        }

        Ok(())
    }

    pub fn handle_rotation(&mut self) -> Result<()> {
        let angle = self.pop_attr("rotate");
        // determine center of rotation; default center of bbox
        let rot_loc = self
            .pop_attr("rotate-loc")
            .unwrap_or("c".to_string())
            .parse()?;
        if angle.is_none() {
            return Ok(());
        }
        let angle = angle.unwrap();
        let angle = strp(&angle)?;
        if let Some((cx, cy)) = self.bbox()?.map(|bb| bb.locspec(rot_loc)) {
            let mut rot_xfrm = TransformAttr::new();
            rot_xfrm.rotate_around(angle, cx, cy);
            if let Some(xfrm) = self.pop_attr("transform") {
                // rotation should be the outermost transform, so prepend it
                self.set_attr("transform", &format!("{rot_xfrm} {xfrm}"));
            } else {
                self.set_attr("transform", &rot_xfrm.to_string());
            }
        }
        Ok(())
    }
}
